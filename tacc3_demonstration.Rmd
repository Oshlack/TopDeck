---
title: "tacc3_demonstration"
output: html_notebook
---

This document outlines how the change in exon expression methods were run using 3' gene TACC3 and cancer type bladder urothelial carcinoma.

First, extract the exon counts for all TCGA samples for gene TACC3
```{r}
#raw_exon_counts requires function set_sb
set_sb <- function(gene) {
  sb <- QueryBuilder(compilation = "tcga", regions = gene) #Extracts all samples from TCGA with data at a specific gene, e.g. TACC3
  sb <- set_coordinate_modifier(sb, Coordinates$Within) #Filters to exons within the canonical boundaries of the gene
  sb <- set_row_filters(sb, strand == "+") #Filters to exons only on the same strand as the canonical transcript
  query_exon(sb) #Extracts data at an exon level
}

raw_exon_counts <- function(gene) {
  exon <- set_sb(gene) #Extract exon data for a specific gene as above
  as.data.frame(as.matrix(assays(exon)$counts)) #Create a dataframe with counts at each exon per the gene
}

tacc3_raw_exon_counts <- raw_exon_counts("TACC3")
```

To calculate the difference between individual exon expression for all recount3 exons.

First, normalise each exon by exon length, using TACC3 metadata. This controls for different sized exons.
```{r}
#norm_length requires function gene_metadata
gene_metadata <- function(gene) {
  info <- set_sb(gene) #uses function set_sb as per above
  as.data.frame(rowRanges(info)) #Summarises information about all recount3 exons in a dataframe
}

#df input is counts matrix as generated by raw_exon_counts
norm_length <- function(gene, df) {
  metadata <- gene_metadata(gene) #Create dataframe with recount3 exon metadata
  width <- metadata$width #width is the exon length in base pairs (bp)
  as.data.frame(df/(width/1000)) #Divide the counts by the length of the exon (width). width is divided by 1,000 to give kilo base pairs (kbp)
}

tacc3_kbp_exon_counts <- norm_length("TACC3", tacc3_raw_exon_counts)
```


To investigate a specific cancer type, bladder urothelial carcinoma, subset by TCGA project ID 'TCGA-BLCA'.

```{r}
#subset_project requires function tcga_info 
tcga_info <- function(gene) {
  info <- set_sb(gene) #Extract exon data for gene
  tcga_info <- cbind(info@colData@rownames, info@colData@listData[["gdc_cases.project.project_id"]], info@colData@listData[["gdc_cases.samples.submitter_id"]], info@colData@listData[["gdc_file_id"]], info@colData@listData[["gdc_cases.samples.sample_type"]]) #Extracts relevant gene metadata from the 841 metadata outputs provided by recount3, including internal/recount3/sample id (rail_id), project name (e.g. 'TCGA-BLCA', project_id), TCGA ID (tcga_id), UCSC ID (UCSC_id), and where is metastatic, primary tumour or solid tissue normal (sample_type)
  tcga_info <- as.data.frame(tcga_info)
  colnames(tcga_info) <- c("rail_id", "project", "tcga_id", "UCSC_id", "sample_type")
  tcga_info$auc <- info@colData@listData[["auc"]] #area under coverage value
  tcga_info$tmc <- info@colData@listData[["mapped_read_count"]] #total mapped count value, an alternative normalisation method not used in this thesis
  tcga_info #All information in a dataframe for downstream analysis
}

#df input is can be any matrix where the column names are sample ids (rail_ids)
subset_project <- function(gene, project_id, df) {
  info <- tcga_info(gene) #Generates dataframe matching rail_id and project_id
  subset <- filter(info, project == project_id) #Subset by project_id, e.g. 'TACC3-BLCA'
  ids <- subset$rail_id #Gets list of rail_ids of all samples with exon counts at a specific gene from one TCGA project
  df[,ids] #Filters input df to only samples belonging to the specific TCGA project
}

tacc3_blca_kbp_exon_counts <- subset_project("TACC3", "TCGA-BLCA", tacc3_kbp_exon_counts)
```

Next, the difference between consecutive exons is calculated, and a new dataframe is created.
```{r}
#df input should be normalised by exon length
diff_calc <- function(df) {
  new_df <- as.data.frame(mapply(diff, df)) #Calculates difference between all consecutive exons, where exon n - exon (n-1), e.g. exon 3 - exon 2
  a <- nrow(df)
  rownames(new_df) <- rownames(df)[2:a] #rownames exon n
  new_df #df output
}

tacc3_blca_kbp_exon_counts_diff <- diff_calc(tacc3_blca_kbp_exon_counts)
```

Next, normalise each exon by area under coverage, auc. This allows comparison between different samples, 
```{r}
#df input should be normalised by exon length and have no further processing within the sample to avoid overprocessing of data
norm_auc <- function(gene, project_id, df) {
  info <- tcga_info(gene)
  info_subset <- filter(info, project == project_id) #Subset gene metadata by project to match data inputs for auc normalisation
  auc <-  info_subset$auc/1000000 #Create auc vector, divide by a million for cpm
  new_df <- as.data.frame(mapply('/', df, auc)) #Divide each sample by its corresponding auc value
  rownames(new_df) <- rownames(df) #Fix rail_ids in auc normalised dataframe
  new_df #df output
}

tacc3_blca_auc_exon_counts_diff <- norm_auc("TACC3", "TCGA-BLCA", tacc3_blca_kbp_exon_counts_diff)
```

To identify samples with a significant difference in exon expression, Z-scores were calculated at each exon. A value > 3 was determined to be significant.
```{r}
#df input should be normalised by exon length and auc to enable comparisons between exons and samples
z_calc <- function (df) {
  mean_df <- apply(df, 1, mean) #Calculate mean at each exon
  sd_df <- apply(df, 1, sd) #Calculate standard deviation at each exon
  new_df <- (df-mean_df)/sd_df #Calculate Z-score for each sample at each exon
  rownames(new_df) <- rownames(df) #Restore rail_ids to new dataframe
  new_df #df output
}

tacc3_blca_auc_exon_counts_diff_z <- z_calc(tacc3_blca_auc_exon_counts_diff)
```
To calculate the number of samples with a significant increase in exon expression at each exon, the number of samples with Z > 3 at each exon were counted. 

The number of samples known to contain fusion genes is counted as well.
```{r}
#summary_significant requires function calc_significant
calc_significant <- function(df) {
  df <- df
  calc <- function(n) {
    sum(df[n,] > 3) #define criteria for significance, Z > 3
  }
  a <- nrow(df)
  final_df <- as.data.frame(sapply(1:a, calc)) #Count number of samples at each exon of significance 
  rownames(final_df) <- rownames(df) #Restore exon names 
  colnames(final_df) <- "All Significant" #Name column
  final_df #df output
}

#summary_significant requires function subset_known
subset_known <- function(gene, project_id, df) {
  ids <- get_known_ids(gene, project_id) #Fetch raiL_ids of samples known to contain fusion genes for that 3' gene
  final_df <- as.data.frame(df[,ids]) #Subset dataframe to just known samples
  colnames(final_df) <- ids #Restore rail_ids
  final_df #df output
}

#df input should be z score dataframe
summary_significant <- function(gene, project_id, df) {
  all_sig <- calc_significant(df) #Count total number of significant samples at each exon
  known_z <- subset_known(gene, project_id, df) #Z scores of samples known to contain fusion genes with that 3' gene
  known_sig <- calc_significant(known_z) #Count number of known samples that are significant at each exon
  final_df <- cbind(all_sig, known_sig) #Merge All and Known dataframes
  colnames(final_df) <- c("All", "Known") #Rename columns to communicate
  final_df #df output
}

summary_significant("TACC3", "TCGA-BLCA", tacc3_blca_auc_exon_counts_diff_z)
```

The most common fusion breakpoint was used to determine if the significant change in exon expression indicated the presence of a fusion gene. This information is listed in the Challenge Report, Table 2. recount3 exon 34, recount3 row identified '12036' was selected for TACC3. 

At 12036, five (of nine) bladder urothelial carcinoma samples known to contain TACC3 fusion genes were correctly identified. One extra bladder urothelial carcinoma sample was also identified as significant.

This process was repeated for all ten 3' genes in the ten test gene set (Table 1) and their corresponding cancer types (Supplementary Table 8). The rail_ids for the true positives (samples identified which are known to contain a fusion gene involving the 3' gene) and false positives (samples which are not known to contain a fusion gene involving the 3' gene).


This process was then repeated using average exon expression, which was calculated from cumulative counts along a gene, e.g. TACC3.

```{r}
#cumsum_calc requires function norm_df
norm_df <- function(gene, df) {
  new_df <- df
  metadata <- gene_metadata(gene) #Generates exon level metadata for the gene
  new_df$width <- metadata$width #Adds column to dataframe with exon length
  new_df #df output
}

#df input is exon counts as generated by recount3
cumsum_calc <- function(gene, df) {
  a <- ncol(df)
  df <- norm_df(gene, df) #Add column to dataframe with exon length
  filt_norm <- function(n) {
    subset_df <- filter(df, df[,n] > 0) #Only keep exons for a sample which are expresed, aka have >0 counts
    cumsum_df <- cumsum(subset_df) #Calculate cumulative counts
    norm_df <- as.data.frame(cumsum_df[,n]/cumsum_df$width*1000) #Normalise sample by cumulative width
    rownames(norm_df) <- rownames(cumsum_df) #Restore rownames
    colnames(norm_df) <- "rail_id" #Enable left_join
    norm_df$rn1 <- as.numeric(rownames(norm_df))
    temp_df <- data.frame(rn1 = as.numeric(rownames(df))) #Fill in missing exons
    new_df <- left_join(temp_df, norm_df) #Merge dataframes
    final_df <- as.data.frame(as.numeric(new_df[,2])) #Convert to numeric then dataframe
    rownames(final_df) <- new_df$rn1 #restore rownames
    colnames(final_df) <- colnames(df)[n] #restore colnames
    final_df #df output
  }
  na_df <- as.data.frame(sapply(1:a, filt_norm)) #Create dataframe with all samples
  rownames(na_df) <- rownames(df)
  filled_df <- na_df %>%
    fill(names(na_df)) #Fill in blank values with previous exon value
  filled_df[is.na(filled_df)] <- 0 #If row 1 has N/A, replace with 0 counts
  filled_df #df output
}

tacc3_cumsum_counts <- cumsum_calc("TACC3", tacc3_raw_exon_counts)
```

Next, calculate the difference between consecutive exons. 
```{r}
tacc3_cumsum_counts_diff <- diff_calc(tacc3_cumsum_counts) #Same as above
```

Then, normalise by auc to allow for comparisons across samples.
```{r}
tacc3_cumsum_counts_diff_auc <- norm_auc(tacc3_cumsum_counts_diff) #Same as above
```

Finally, calculate Z-scores and create dataframe informing the number of samples that are significantly expressed at recount3 exon 34. The same five samples were identified as having a significant (Z > 3) change in exon expression at recount3 exon 34.

```{r}
tacc3_cumsum_counts_diff_auc_z <- z_calc(tacc3_cumsum_counts_diff_auc) #Get Z-scores as per above
summary_significant("TACC3", "TCGA-BLCA", tacc3_cumsum_counts_diff_auc_z) #Generate summary dataframe as per above
```

The cumulative counts dataframe was used to visualise the average exon expression along the gene, e.g. TACC3.

```{r}
#df input should be normalised by exon length and auc
graph_log <- function(gene, project_id, df, title, xlabel, ylabel, legend) {
  known_df <- as.data.frame(subset_known(gene, project_id, df)) #Generate subset of samples known to contain fusion genes
  all_df <- df #All samples
  n <- nrow(df)
  known_df$Exon <- 1:n #Generate exon numbers
  known_long <- melt(known_df, id.vars = "Exon") #'melt' data to graph along a gene by sample
  all_df$Exon <- 1:n #Generate exon numbers
  all_long <- melt(all_df, id.vars = "Exon") #'melt' data to graph along a gene by sample
  
  ggplot(data = all_long, aes(x = Exon, y = log2(value), group = variable)) + #Transform values by log2
    geom_line(color = "grey") + #Colour samples without fusion genes grey
    geom_line(data = known_long, aes(x = Exon, y = log2(value), group = variable, color = variable)) + #Colour known samples by rail_id
    geom_point(data = known_long, aes(x = Exon, y = log2(value), group = variable, color = variable)) + #Colour known samples by rail_id
    ylab(ylabel) + #Label y-axis counts with normalisation method
    xlab(xlabel) + #Label x-axis "Exon"
    theme(legend.position = legend) + #Position to display legend of known fusion samples or none for no legend
    ggtitle(title) #Title of graph
} 
#function graph_notlog has the same effect except y values are not transformed by log2

graph_log("TACC3", "TCGA-BLCA", tacc3_cumsum_counts, "Average exon expression along TACC3 for all bladder urothelial carcinoma samples", "Exon #", "Cumulative counts (auc, kbp normalised) (cpm)", "right")
```


